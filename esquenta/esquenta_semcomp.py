# -*- coding: utf-8 -*-
"""esquenta_semcomp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xtMR4zUu6AtSMnEnKIN9dA3b9lAKWorP

## Predizendo preços de casas

Queremos pegar dados sobre diversas casas e tentar advinhar quais os preços que elas serão vendidas. Para isso vamos usar um modelo de aprendizagem de máquina que simule essa situação.

Clicar com o botão direito e mandar um save link as: https://github.com/cassiasamp/semcomp/tree/master/dados

Precisamos ler os dados, para ler os dados vamos usar o pandas.
"""

import pandas as pd

dados_treino = pd.read_csv('treino.csv')

"""Agora que fizemos o carregamento dos dados em um dataframe do pandas, podemos dar uma olhada neles com .head()."""

dados_treino.head(5)

"""Repare que ficamos com uma coluna com 0, 1, 2, 3, 4 e que já temos nos dados uma coluna chamada Id, então vamos arrumar isso dizendo para o pandas que essa coluna já é um índice."""

dados_treino = pd.read_csv('treino.csv', index_col='Id')

"""Vamos dar uma olhada novamente para ver se está tudo certo com os dados."""

dados_treino.head(5)

dados_treino.info()

"""Repare que temos 80 colunas nos nossos dados, e 1460 entradas.

Legal, temos os dados de treino, agora falta importarmos os dados de teste.
"""

dados_teste = pd.read_csv('teste.csv')

"""Vamos dar uma olhada nos dados também."""

dados_teste.head(5)

"""Repare que temos a mesma situação com o id, então, vamos dizer qual a coluna de indice."""

dados_teste = pd.read_csv('teste.csv', index_col='Id')

"""Vamos conferir se está tudo certo novamente."""

dados_teste.head(5)

"""Beleza, agora temos nossos dados de treino e teste, podemos começar a mexer neles. Vamos dar uma olhada nas colunas dos nossos dados de treino."""

dados_treino.columns

"""Repare naquela última coluna, ela é coluna que queremos advinhar pois tem os preços de venda das casas e é chamada **SalePrice**.
Como SalePrice é o que queremos advinhar, vou criar um novo dataframe que contém apenas essa coluna e chamá-lo de y.
"""

y = dados_treino.SalePrice

"""Vamos dar uma olhadinha no nosso y."""

y.head(5)

"""Repare que temos o id e os preços de cada casa. Tudo certo.

Temos o nosso y, e qual será o nosso X? Podemos escolher algumas características dos nossos dados, algumas dessas colunas para fazermos a predição.
Vou escolher 7 colunas:


*   área do lote ou **LotArea**
*   ano de construção da casa ou **YearBuilt**
*   tamanho do 1° andar ou **1stFlrSF**
*   tamanho do 2° andar ou **2ndFlrSF**
*   banheiros completos acima do térreo ou **FullBath**
*   dormitórios acima do térreo  ou **BedroomAbvGr**
*   total de quartos acima do térreo ou **TotRmsAbvGrd**
"""

caracteristicas = ['LotArea', 'YearBuilt', '1stFlrSF', '2ndFlrSF', 
                   'FullBath', 'BedroomAbvGr','TotRmsAbvGrd']

"""Para garantir que não estamos alterando os nossos dados de treino originais, vamos criar uma cópia deles para ser o nosso X apenas com as características que queremos usar.

Fazemos isso usando o .copy() do pandas.
"""

X = dados_treino[caracteristicas].copy()

X.info()

"""Beleza, agora temos nosso X e y, o que podemos fazer? Dividir os nossos dados para alimentar nosso modelo.

Para evitarmos usar os nossos dados de teste nesse momento, vamos dividir os dados de X e y entre treino e validação. Usaremos os dados de teste mais para frente apenas para saber como o nosso modelo está generalizando.

Nessa divisão vou reservar 80% dos dados para treino e 20% para validação. Aqui também não há uma regra.

Assim como chamar de X e y, há diferentes formar de nomear as divisões no split, por exemplo, podemos usar treino e teste aqui e validacao para o que vamos fazer com teste.

Para isso precisamos importar a função de split do sklearn e vamos definir um estados chamado random_state como 42 para garantir que o resultado permaneça o mesmo.
"""

from sklearn.model_selection import train_test_split

X_treino, X_valid, y_treino, y_valid = train_test_split(X, y, 
                                                    train_size=0.8, 
                                                    test_size=0.2, 
                                                    random_state=42)

"""Agora que dividimos os nossos dados, podemos criar um modelo e alimentá-lo ou fazer o fit. Vamos usar um modelo de árvore de decisão chamado DecisionTreeRegressor.

Vamos adicionar aqui também um random_state para garantir que os resultados sejam os mesmos ou sua replicabilidade.
"""

from sklearn import tree

modelo = tree.DecisionTreeRegressor(random_state=42)

modelo.fit(X, y)

"""Depois do fit o que falta? Fazer predicoes, tentar adivinhar os preços das casas dos dados. Então, vamos lá fazer isso com .predict() e os dados de validação."""

predicoes = modelo.predict(X_valid)

"""Bacana, acabamos de ajustar o nosso modelo de árvore com ao nosso X e y e fazer a predição, mas será que ele é bom? Para saber como ele está indo, vamos usar uma medida de erro chamada MAE."""

from sklearn.metrics import mean_absolute_error

mae = mean_absolute_error(y_valid, predicoes)

mae

"""E veja o que a nossa métrica nos devolveu, estamos errando com 86,8 doláres de diferença no geral. Podemos mostrar isso de um jeito mais legal, inclusive."""

print('MAE do modelo de árvore: %d'% mae)

"""Nós pegamos os nossos dados, fizemos cópias, escolhemos features, separamos, criamos o modelo, ajustamos, predizemos, vimos a métrica e agora? Agora falta saber como seria no teste, como seria no mundo real, para isso, vamos usar o nosso conjunto de dados de teste.

Como selecionamos 7 caracteristicas ou features para os dados de treino, precisamos fazer o mesmo para os dados de teste, senão não temos como comparar um com o outro, então vamos repetir a selecao de features e a copia do dataframe.
"""

X_teste = dados_teste[caracteristicas].copy()

X_teste.info()

predicoes_teste = modelo.predict(X_teste)

"""Beleza, agora fizemos as predicoes para dados desconhecidos e o que podemos fazer? Podemos salvar esses resultado em um arquivo."""

predicoes_teste

"""Repare que o que as predicoes nos devolvem são arrays, entao podemos colocar esses valores em um dicionario identificando os campos. Para cada entrada de uma casa no indice, temos um valor de predicao."""

resultados_arvore = {'Id': X_teste.index, 'SalePrice': predicoes_teste}

"""Agora, podemos passar esse dicionario para um dataframe e retornar um csv.

Do mesmo jeito que carregamos os nossos dados com read_csv, podemos usar o pandas para salvar os nossos dados nesse formato com to_csv. 

Quando o pandas faz isso ele cria automaticamente uma coluna de índice, mas queremos manter o Id como indice, então vamos passar um index=False.
"""

resultados = pd.DataFrame(resultados_arvore)
resultados.to_csv('resultados_arvore.csv', index=False)